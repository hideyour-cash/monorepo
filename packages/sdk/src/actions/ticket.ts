import { mimc as mimcService } from "../services";
import { viewAccountHash } from "../views";
import { sendTransactionsCallback } from "./connection";
import type { ConnectionType, Currency } from "../interfaces";
import { getTransaction, randomBN, viewFunction } from "../helpers";

/**
 * Create Ticket
 *
 * This method is responsible for generating a new ticket for deposit.
 *
 * @param nodeRpcUrl The proof generated by plonk
 * @param contract The HYC registry accountId
 * @param accountId The user accountId
 * @param currencyId The instance accountId to be send deposit
 * @returns {Promise<{ note: string, hash: string}>}
 */
export const createTicket = async (
  nodeRpcUrl: string,
  contract: string,
  accountId: string,
  currencyId: string,
  skip = false,
) => {
  const { hash } = await mimcService.initMimc();

  const secret = randomBN();
  const nullifier = randomBN();

  const secretsHash = hash!(secret!, nullifier!);

  const accountHash = await viewAccountHash(nodeRpcUrl, contract, accountId);

  const note =
    currencyId.toString() +
    "-" +
    secret!.toString() +
    "-" +
    nullifier!.toString() +
    "-" +
    accountHash!.toString();

  return {
    note: skip ? note : Buffer.from(note).toString('hex'),
    hash: secretsHash,
  };
};

/**
 * Send deposit
 *
 * This method is responsible for sending a new deposit with a unique commitment hash to the instance.
 *
 * @param hash The generated deposit hash
 * @param amount The amount to be deposited
 * @param depositContract The instance accountId to be receive deposit
 * @param accountId The signer accountId of the transaction
 * @param currency The data of currency with token accountId
 * @param connection the near connection that will to sign the transactions (Near Account or Wallet Selector)
 * @returns {Promise<any>}
 */
export const sendDeposit = async (
  hash: string,
  amount: string,
  depositContract: string,
  accountId: string,
  currency: Currency,
  connection: ConnectionType
) => {
  const transactions: any[] = [];

  if (currency.type === "Nep141") {
    const tokenContract = currency.account_id || "";

    transactions.push(
      getTransaction(accountId, tokenContract, "ft_transfer_call", {
        amount,
        msg: hash,
        memo: null,
        receiver_id: depositContract,
      })
    );
  }

  if (currency.type === "Near") {
    transactions.push(
      getTransaction(
        accountId,
        depositContract,
        "deposit",
        {
          secrets_hash: hash,
        },
        amount,
        true
      )
    );
  }

  return await sendTransactionsCallback(connection, transactions);
};

/**
 * Get Token Storage
 *
 * This method serves to fetch the storage of an accountId in a token contract.
 *
 * @param contract The contract accountId
 * @param accountId The user accountId to check storage
 * @param nodeUrl The Near RPC to send the transaction
 * @returns {Promise<any>}
 */
export const getTokenStorage = async (
  contract: string,
  accountId: string,
  nodeRpcUrl: string
) => {
  try {
    return await viewFunction(nodeRpcUrl, contract, "storage_balance_of", {
      account_id: accountId,
    });
  } catch (e) {
    console.warn(e);

    return;
  }
};
